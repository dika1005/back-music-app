generator client {
  provider = "prisma-client-js"
}

generator prismabox {
  provider = "prismabox"
  output   = "../src/generated/prismabox"
  typeboxImportVariableName = "t"
  typeboxImportDependencyName = "elysia"
}

datasource db {
  provider = "mysql"
}

model user {
  id            String    @id
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  sessions    session[]      // ✅ lowercase
  accounts    account[]      // ✅ lowercase
  favorites   Favorite[]
  playlists   Playlist[]
  history     History[]
  offlineSync OfflineSync[]
}

model session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?  @db.Text
  userId    String
  user user @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId])
}
model account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  idToken               String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user user @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId])
}
model verification {
  id         String   @id
  identifier String
  value      String   @db.Text
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Favorite {
  id        String   @id @default(cuid())
  userId    String
  songId    String
  songData  Json
  createdAt DateTime @default(now())

  user user @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, songId])
  @@index([userId])
  @@map("favorites")
}

model Playlist {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?  @db.Text
  coverImage  String?  @db.Text
  isPublic    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user  user           @relation(fields: [userId], references: [id], onDelete: Cascade)
  songs PlaylistSong[]

  @@index([userId])
  @@map("playlists")
}

model PlaylistSong {
  id         String   @id @default(cuid())
  playlistId String
  songId     String
  songData   Json
  position   Int
  addedAt    DateTime @default(now())

  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)

  @@unique([playlistId, songId])
  @@index([playlistId])
  @@map("playlist_songs")
}

model History {
  id       String   @id @default(cuid())
  userId   String
  songId   String
  songData Json
  playedAt DateTime @default(now())

  user user @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, playedAt])
  @@map("history")
}

model OfflineSync {
  id       String   @id @default(cuid())
  userId   String
  songId   String
  songData Json
  syncedAt DateTime @default(now())

  user user @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, songId])
  @@index([userId])
  @@map("offline_sync")
}